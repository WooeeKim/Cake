<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Make a Cake with Me! - Naeun Kim (v2)</title>
  <style>
    :root{
      --bg:#0e0f14; /* dark room */
      --cake:#f7d8bf; /* sponge */
      --icing:#fff4fb; /* icing */
      --plate:#dde3ea;
      --accent:#ff7a99;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{
      background: radial-gradient(1200px 600px at 50% 80%, #ffeef5 0%, #e9f5ff 60%, #fff6e9 100%);
      color:#6a5d7b;font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      overflow:hidden;
    }
    #hud{
      position:fixed; left:16px; top:16px; padding:12px 14px; border-radius:14px;
      background:rgba(255,255,255,0.06); backdrop-filter: blur(6px);
      line-height:1.4; font-size:14px; max-width: 560px; border:1px solid rgba(255,255,255,0.1);
      transition: opacity .25s ease, transform .25s ease, visibility .25s;
    }
    #hud.hidden{ opacity:0; transform: translateY(-6px); visibility:hidden; }
    #hud kbd{background:#22263a;border:1px solid #2f3552;padding:2px 6px;border-radius:6px}
    #hud .mini{font-size:12px; color:#b9c2df}

    #hud-toggle{
      position:fixed; left:16px; top:16px; width:36px; height:36px; border-radius:10px;
      background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.12);
      display:grid; place-items:center; cursor:pointer; font-weight:800; user-select:none;
      transition: transform .15s ease; backdrop-filter: blur(6px);
    }
    #hud-toggle:hover{ transform: scale(1.05); }

    #stage{position:relative; width:100%; height:100%;}

    /* Roof */
    .roof{ position:absolute; left:50%; top:0; transform:translateX(-50%);
      width: 84vw; height: 42px; border-radius:0 0 18px 18px;
      background:
        repeating-linear-gradient( 90deg, #5b4525 0 18px, #6d5330 18px 36px),
        linear-gradient(#8b6a3c, #5b4525 66%);
      box-shadow: 0 6px 12px rgba(0,0,0,0.35);
      overflow:hidden;
    }
    .roof::after{ /* straw fringe */
      content:""; position:absolute; inset:auto 0 -14px 0; height:22px;
      background: repeating-linear-gradient(90deg, #e7ba66 0 2px, transparent 2px 8px);
      filter: drop-shadow(0 6px 4px rgba(0,0,0,0.35));
      opacity:0.7;
    }

    /* Plate */
    .plate{ position:absolute; left:50%; bottom:4%; transform:translateX(-50%);
      width: 56vw; height: 2.6vw; min-height:18px; background: var(--plate);
      border-radius: 80px; filter: drop-shadow(0 24px 40px rgba(0,0,0,0.35));
    }
    /* Cake body */
    .cake{ position:absolute; left:50%; bottom:7.5%; transform:translateX(-50%);
      width: 48vw; max-width: 900px; min-width: 360px; height: 24vw; min-height: 240px;
      background: linear-gradient(#ffe7de, var(--cake)); border-radius: 24px; overflow:visible;
      box-shadow: inset 0 -16px 0 var(--icing), 0 40px 80px rgba(0,0,0,0.15);
    }
    .cake::after{ /* icing drip rim */
      content:""; position:absolute; left:0; right:0; top:0; height: 44px; border-radius:24px 24px 0 0;
      background: linear-gradient(180deg, var(--icing), #ffdbe9 80%);
      mask: radial-gradient(30px 12px at 8% 14px, #000 95%, transparent 100%),
            radial-gradient(40px 16px at 30% 14px, #000 95%, transparent 100%),
            radial-gradient(28px 12px at 54% 14px, #000 95%, transparent 100%),
            radial-gradient(36px 12px at 74% 14px, #000 95%, transparent 100%),
            radial-gradient(30px 12px at 90% 14px, #000 95%, transparent 100%);
      mask-composite: exclude;
    }

    /* Candles */
    .candle{ 
      position:absolute; 
      bottom: calc(24vw - 8px);
      width: 6px;
      height: 120px;
      background: linear-gradient(to bottom, #ffd700, #ffeb7b);
      border-radius: 3px;
      filter: drop-shadow(0 4px 6px rgba(0,0,0,0.2));
      user-select:none;
    }
    .candle::after {
      content: "🔥";
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 20px;
    }

    /* Falling bits (letters / toppings) */
    .bit{ position:absolute; top:-40px; font-weight:700; font-size: clamp(16px, 1.6vw, 28px); user-select:none; }
    .bit.letter{ color:#fff; text-shadow: 0 2px 0 rgba(0,0,0,0.4), 0 0 18px rgba(255,174,213,0.35);}    
    .bit.topping{ filter: drop-shadow(0 2px 2px rgba(0,0,0,0.35)); font-size: clamp(20px, 1.8vw, 34px);}    
    .bit.giant{ font-size: clamp(64px, 7vw, 120px); }

    .sprinkle{ width:8px; height:8px; border-radius:50%; position:absolute; top:-10px; }

    @keyframes fall { to { transform: translateY(86vh); opacity: 1; } }
    @keyframes eat  { to { transform: translateX(120vw) rotate(8deg); opacity:0 } }

    .falling{ animation: fall linear var(--dur,3.2s); }
    .eaten{ animation: eat 900ms ease-in forwards; }

    /* Room lighting when candles on */
    .warm{ background: radial-gradient(1200px 600px at 50% 65%, #3a2b1d 0%, #1b1d29 40%, var(--bg) 75%); }

    /* Guest hand */
    .hand{ position:absolute; right:-20vw; top:40%; font-size: clamp(42px, 6vw, 100px); filter: drop-shadow(0 8px 14px rgba(0,0,0,0.35));}

    /* Footer + Buttons */
    #footer{ position:fixed; right:16px; bottom:14px; opacity:0.85; font-size:12px; color:#b7bfd8; }
    .pill{
      position:fixed; right:16px; bottom:46px; padding:10px 12px; border-radius:999px; cursor:pointer;
      background: rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.12); user-select:none;
      backdrop-filter: blur(6px); transition: transform .12s ease; font-size:13px; color:#e7eaf6;
    }
    .pill:active{ transform: translateY(1px); }
  </style>
</head>
<body>
  <div id="hud-toggle" title="도움말 보기/숨기기">?</div>
  <div id="hud">
    <div><strong>Make a Cake with Me! - Naeun Kim</strong></div>
    <div class="mini">글자가 케이크에 쌓여요 • 손님이 가져가요 🍰 → <kbd>Enter</kbd> 또는 버튼</div>
    <div>일반 키: <em>글자</em>가 케이크에 층층이 쌓여요</div>
    <div><kbd>Space</kbd>: 촛불 켜기/끄기 / <kbd>Enter</kbd>: 손님이 가져가요(초기화)</div>
    <div>숫자키: 스프링클 • 가끔은 깜짝 수박🍉이 등장해요!</div>
    <div class="mini">과일 단축키를 찾으려면 물음표(?) 아이콘을 클릭해보세요</div>
    <div class="fruit-keys" style="display: none;">
      🍓: F키 / 🍎: A키 / 🫐: B키 / 🍒: C키 / 🍇: G키<br>
      🥭: M키 / 🥝: K키 / 🍑: P키 / 🍊: O키 / �: L키
    </div>
  </div>

  <div id="stage">
    <div class="roof" aria-hidden="true"></div>
    <div class="plate"></div>
    <div id="cake" class="cake" aria-label="cake"></div>
  </div>

  <button id="resetBtn" class="pill" title="손님이 가져가요">🫱🏻‍🍰 손님이 가져가요</button>
  <div id="footer">type to play • made for ID202 prototyping</div>

  <script>
  // ===== Audio — tiny synth & candle pad =====
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let audioContext = null;
  function getAudioContext(){ if(!audioContext) audioContext = new AudioCtx(); return audioContext; }

  function noteForKey(key){
    const scale = [261.63, 293.66, 329.63, 392.00, 440.00]; // C D E G A
    const index = (key.toUpperCase().charCodeAt(0) + 7) % scale.length;
    return scale[index] * (1 + ((key.charCodeAt(0)%5)-2)*0.01);
  }

  function blip(key){
    const ac = getAudioContext();
    const osc = ac.createOscillator();
    const gain = ac.createGain();
    osc.type = 'triangle';
    osc.frequency.value = noteForKey(key);
    gain.gain.value = 0.001;
    osc.connect(gain).connect(ac.destination);
    const now = ac.currentTime;
    gain.gain.linearRampToValueAtTime(0.12, now + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0008, now + 0.22);
    osc.start();
    osc.stop(now + 0.25);
  }

  let candleOsc = null, candleGain = null;
  function candleOn(){
    const ac = getAudioContext();
    candleOsc = ac.createOscillator();
    candleGain = ac.createGain();
    candleOsc.type = 'sine';
    candleOsc.frequency.value = 196;
    candleGain.gain.value = 0.0001;
    candleOsc.connect(candleGain).connect(ac.destination);
    const now = ac.currentTime;
    candleGain.gain.linearRampToValueAtTime(0.06, now + 0.6);
    candleOsc.start();
  }
  function candleOff(){
    if(!candleGain || !candleOsc) return;
    const ac = getAudioContext();
    const now = ac.currentTime;
    candleGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.2);
    candleOsc.stop(now + 0.25);
    candleGain = null; candleOsc = null;
  }

  // ===== Scene =====
  const stage = document.getElementById('stage');
  const cake  = document.getElementById('cake');
  const hud   = document.getElementById('hud');
  const hudToggle = document.getElementById('hud-toggle');
  const resetBtn = document.getElementById('resetBtn');
  let candlesLit = false;

  const randomBetween = (min,max)=> Math.random()*(max-min)+min;
  function cakeRect(){ return cake.getBoundingClientRect(); }

    // ===== Random pile stacking =====
  const stacking = {
    baseTop: 0,
    baseLeft: 0,
    width: 0,
    recompute(){
      const cr = cakeRect();
      this.baseTop = cr.top;
      this.baseLeft = cr.left;
      this.width = cr.width;
    },
    placeAt(xCenter, node){
      const cr = cakeRect();
      if (node.classList.contains('candle')) {
        // Candles need precise placement on top of cake
        const x = this.baseLeft + (this.width * (Math.random() * 0.6 + 0.2));
        node.style.left = x + 'px';
        node.style.bottom = cr.height + 'px';
        node.classList.remove('falling');
        return;
      }
      
      // Place items on cake surface
      const x = this.baseLeft + (this.width * 0.1) + Math.random() * (this.width * 0.8);
      node.style.left = x + 'px';
      node.style.top = (cr.top - 10) + 'px';
      node.style.position = 'absolute';
      node.style.zIndex = Math.floor(Math.random() * 100);
      node.style.transform = `rotate(${randomBetween(-15, 15)}deg)`;
      node.classList.remove('falling');
    },
    reset(){ this.recompute(); }
  };

  // initialize stacking after layout
  window.addEventListener('load', ()=> stacking.recompute());
  window.addEventListener('resize', ()=> stacking.recompute());

  // ===== Candles =====
  function placeCandles(){
    [...document.querySelectorAll('.candle')].forEach(c=>c.remove());
    const cr = cakeRect();
    const count = 5;
    for(let i=0;i<count;i++){
      const c = document.createElement('div');
      c.className = 'candle';
      c.innerHTML = '<div class="flame">�</div>';
      const x = (cr.left + (cr.width*(0.15 + i*(0.7/(count-1))))) - 14;
      c.style.left = x + 'px';
      stage.appendChild(c);
    }
  }
  function toggleCandles(){
    candlesLit = !candlesLit;
    if(candlesLit){
      placeCandles();
      document.body.classList.add('warm');
      candleOn();
    } else {
      document.body.classList.remove('warm');
      candleOff();
      [...document.querySelectorAll('.candle')].forEach(c=>c.remove());
    }
  }

  // ===== Spawn helpers =====
  function spawnBit({ text, className, emoji, color, fromRoof=false, giant=false, group=false }){
    const bit = document.createElement('div');
    bit.className = 'bit falling ' + (className||'');
    if(giant) bit.classList.add('giant');
    bit.style.setProperty('--dur', (randomBetween(2.0, 3.6)).toFixed(2)+'s');

    const stageRect = stage.getBoundingClientRect();
    const roof = document.querySelector('.roof').getBoundingClientRect();
    const x = fromRoof
      ? randomBetween(roof.left + 20, roof.right - 20)
      : randomBetween(stageRect.width*0.18, stageRect.width*0.82);

    bit.style.left = x + 'px';
    bit.style.opacity = 0.96;

    if(emoji){ bit.textContent = emoji; }
    else if(text){ bit.textContent = text; }
    if(color){ bit.style.color = color; }

    stage.appendChild(bit);

    bit.addEventListener('animationend', ()=> {
      const cr = cakeRect();
      const bx = bit.getBoundingClientRect().left + bit.offsetWidth/2;
      if(bx > cr.left && bx < cr.right){
        stacking.placeAt(bx, bit);
      } else {
        bit.remove();
      }
    });

    // Optional group cascade (3 quick neighbors)
    if(group){
      for(let i=0;i<3;i++){
        setTimeout(()=>{
          spawnBit({ text, className, emoji, color, fromRoof:true });
        }, 120 + i*80);
      }
    }
  }

  function sprinkle(){
    const s = document.createElement('div');
    s.className = 'sprinkle falling';
    const stageRect = stage.getBoundingClientRect();
    s.style.left = randomBetween(stageRect.width*0.2, stageRect.width*0.8)+'px';
    const palette = ['#ff7a99','#ffd166','#8be9fd','#c2ff8f','#b197fc'];
    s.style.background = palette[Math.floor(randomBetween(0, palette.length))];
    s.style.setProperty('--dur', (randomBetween(1.6, 2.6)).toFixed(2)+'s');
    stage.appendChild(s);
    s.addEventListener('animationend', ()=> s.remove());
  }

  // ===== Guest arrives (reset) =====
  function guestEat(){
    const hand = document.createElement('div');
    hand.className = 'hand';
    hand.textContent = '🫱🏻\u200d🍰';
    stage.appendChild(hand);

    cake.classList.add('eaten');
    setTimeout(()=>{
      [...document.querySelectorAll('.bit,.sprinkle,.candle')].forEach(n=>n.remove());
      document.body.classList.remove('warm');
      candleOff();
      candlesLit = false;
      cake.classList.remove('eaten');
      hand.remove();
      stacking.reset();
    }, 950);
  }

  // ===== Input handling + playful surprises =====
  const toppingMap = { 'f':'🍓','a':'🍎','b':'🫐','c':'🍒','g':'🍇','m':'🥭','k':'🥝','p':'🍑','o':'🍊','l':'🍋' };
  const fruits = Object.values(toppingMap);
  let keyPressCount = 0;
  let gDownAt = 0; // long-press protection for G

  function randomFruit(){ return fruits[Math.floor(Math.random()*fruits.length)]; }

  function maybeSurprise(){
    // Every 10th press → giant watermelon
    if(keyPressCount > 0 && keyPressCount % 10 === 0){
      spawnBit({ emoji:'🍉', className:'topping', fromRoof:true, giant:true, group:true });
    }
  }

  function handleKeyDown(e){
    if(e.key === ' '){ e.preventDefault(); }
    if(audioContext && audioContext.state === 'suspended') audioContext.resume();

    // HUD toggle with '?'
    if(e.key === '?' || (e.shiftKey && e.key === '/')){ hud.classList.toggle('hidden'); return; }

    // Space → candles
    if(e.key === ' '){ toggleCandles(); return; }

    // Enter to reset
    if(e.key === 'Enter'){ guestEat(); return; }

    // Numbers → sprinkles
    if(/[0-9]/.test(e.key)){ keyPressCount++; sprinkle(); blip(e.key); maybeSurprise(); return; }

    const keyLower = e.key.toLowerCase();

    // Fruits via explicit hotkeys OR random fruit (20% chance) even for letters
    if(toppingMap[keyLower] || Math.random() < 0.2){
      keyPressCount++;
      const emo = toppingMap[keyLower] || randomFruit();
      spawnBit({ emoji: emo, className:'topping', fromRoof: Math.random()<0.5 });
      blip(keyLower);
      maybeSurprise();
      return;
    }

    // Letters and symbols → falling letters
    if(e.key.length === 1){
      keyPressCount++;
      spawnBit({ text: e.key, className:'letter', fromRoof: Math.random()<0.6 });
      blip(e.key);
      maybeSurprise();
      return;
    }

    // Backspace removes last landed element
    if(e.key === 'Backspace'){
      const bits = [...document.querySelectorAll('.bit')];
      if(bits.length){ bits[bits.length-1].remove(); }
      return;
    }
  }

  function handleKeyUp(e){
    // No longer need to handle key up events
  }

  // HUD toggle button + auto-hide
  hudToggle.addEventListener('click', ()=> {
    hud.classList.toggle('hidden');
    document.querySelector('.fruit-keys').style.display = 
      hud.classList.contains('hidden') ? 'none' : 'block';
  });
  setTimeout(()=> hud.classList.add('hidden'), 5200);

  // Reset pill button
  resetBtn.addEventListener('click', guestEat);

  window.addEventListener('keydown', handleKeyDown);
  window.addEventListener('keyup', handleKeyUp);

  // Reposition candles on resize
  window.addEventListener('resize', ()=>{ if(candlesLit) placeCandles(); });
  </script>
</body>
</html>
