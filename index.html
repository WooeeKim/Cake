<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Make a Cake with Me! - Naeun Kim (v2)</title>
  <style>
    :root{
      --bg:#fef6f8; /* pastel background */
      --cake:#ffe6e6; /* pastel pink cake */
      --icing:#fff9fc; /* light pink icing */
      --plate:#f0f7ff; /* light blue plate */
      --accent:#ffb5c9; /* soft pink accent */
      --candle-colors: #ffd6e6, #c9f4ff, #ffecd6, #e8ffd6, #e5d6ff, #ffd6d6;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{
      /* darker pastel edges for better contrast with the cake */
      background: radial-gradient(1200px 600px at 50% 80%, #fff6fb 0%, #f1e7f6 35%, #e1d1ea 65%, #cbb8dd 100%);
      color:#4a324a;font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      overflow:hidden;
    }
    #hud{
      position:fixed; left:16px; top:16px; padding:12px 14px; border-radius:14px;
      background:rgba(255,255,255,0.06); backdrop-filter: blur(6px);
      line-height:1.4; font-size:14px; max-width: 560px; border:1px solid rgba(255,255,255,0.1);
      transition: opacity .25s ease, transform .25s ease, visibility .25s;
    }
    #hud.hidden{ opacity:0; transform: translateY(-6px); visibility:hidden; }
    #hud kbd{background:#22263a;border:1px solid #2f3552;padding:2px 6px;border-radius:6px}
    #hud .mini{font-size:12px; color:#b9c2df}

    #hud-toggle{
      position:fixed; left:16px; top:16px; width:36px; height:36px; border-radius:10px;
      background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.12);
      display:grid; place-items:center; cursor:pointer; font-weight:800; user-select:none;
      transition: transform .15s ease; backdrop-filter: blur(6px);
    }
    #hud-toggle:hover{ transform: scale(1.05); }

    #stage{position:relative; width:100%; height:100%;}

  /* roof removed intentionally */

    /* Plate */
    .plate{ position:absolute; left:50%; bottom:4%; transform:translateX(-50%);
      width: 56vw; height: 2.6vw; min-height:18px; background: var(--plate);
      border-radius: 80px; filter: drop-shadow(0 24px 40px rgba(0,0,0,0.35));
    }
    /* Cake body */
    .cake{ position:absolute; left:50%; bottom:7.5%; transform:translateX(-50%);
      width: 48vw; max-width: 900px; min-width: 360px; height: 24vw; min-height: 240px;
      background: linear-gradient(#ffe7de, var(--cake)); border-radius: 24px; overflow:visible;
      box-shadow: inset 0 -16px 0 var(--icing), 0 40px 80px rgba(0,0,0,0.15);
    }
    .cake::after{ /* icing drip rim */
      content:""; position:absolute; left:0; right:0; top:0; height: 44px; border-radius:24px 24px 0 0;
      background: linear-gradient(180deg, var(--icing), #ffdbe9 80%);
      mask: radial-gradient(30px 12px at 8% 14px, #000 95%, transparent 100%),
            radial-gradient(40px 16px at 30% 14px, #000 95%, transparent 100%),
            radial-gradient(28px 12px at 54% 14px, #000 95%, transparent 100%),
            radial-gradient(36px 12px at 74% 14px, #000 95%, transparent 100%),
            radial-gradient(30px 12px at 90% 14px, #000 95%, transparent 100%);
      mask-composite: exclude;
    }

    /* Candles */
    .candle{ 
      position:absolute; 
      bottom: calc(24vw - 8px);
      width: 4px;
      height: 100px;
      border-radius: 2px;
      background: linear-gradient(to bottom, var(--accent), #ffffff);
      user-select:none;
      transform-origin: bottom center;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    .candle.lit {
      filter: drop-shadow(0 0 8px rgba(255, 200, 100, 0.5));
    }
    .candle.lit::after {
      content: "";
      position: absolute;
      top: -8px;
      left: 50%;
      transform: translateX(-50%);
      width: 12px;
      height: 12px;
      background: radial-gradient(circle at center, #fff7c9 20%, #ffed4a 45%, transparent 70%);
      border-radius: 50%;
      animation: flicker 1s ease-in-out infinite alternate;
      box-shadow: 
        0 0 15px 5px rgba(255, 237, 74, 0.4),
        0 0 30px 15px rgba(255, 186, 66, 0.2);
    }
    
    @keyframes flicker {
      0% { transform: translateX(-50%) scale(1); opacity: 0.9; }
      100% { transform: translateX(-50%) scale(1.1); opacity: 1; }
    }

    /* Falling bits (letters / toppings) */
    .bit{ position:absolute; top:-40px; font-weight:700; font-size: clamp(16px, 1.6vw, 28px); user-select:none; }
    .bit.letter{ color:#fff; text-shadow: 0 2px 0 rgba(0,0,0,0.4), 0 0 18px rgba(255,174,213,0.35);}    
    .bit.topping{ filter: drop-shadow(0 2px 2px rgba(0,0,0,0.35)); font-size: clamp(20px, 1.8vw, 34px);}    
    .bit.giant{ font-size: clamp(64px, 7vw, 120px); }

    .sprinkle{ width:8px; height:8px; border-radius:50%; position:absolute; top:-10px; }

    @keyframes fall { to { transform: translateY(86vh); opacity: 1; } }
    @keyframes eat  { to { transform: translateX(120vw) rotate(8deg); opacity:0 } }

    .falling{ animation: fall linear var(--dur,3.2s); }
    .eaten{ animation: eat 900ms ease-in forwards; }

    /* Room lighting when candles on */
    .warm{ background: radial-gradient(1200px 600px at 50% 65%, #3a2b1d 0%, #1b1d29 40%, var(--bg) 75%); }

    /* Guest hand */
    .hand{ position:absolute; right:-20vw; top:40%; font-size: clamp(42px, 6vw, 100px); filter: drop-shadow(0 8px 14px rgba(0,0,0,0.35));}

    /* Footer + Buttons */
    #footer{ position:fixed; right:16px; bottom:14px; opacity:0.85; font-size:12px; color:#b7bfd8; }
    .pill{
      position:fixed; right:16px; bottom:46px; padding:10px 12px; border-radius:999px; cursor:pointer;
      background: rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.12); user-select:none;
      backdrop-filter: blur(6px); transition: transform .12s ease; font-size:13px; color:#e7eaf6;
    }
    .pill:active{ transform: translateY(1px); }
  </style>
</head>
<body>
  <div id="hud-toggle" title="도움말 보기/숨기기">?</div>
  <div id="hud">
    <div><strong>Make a Cake with Me! - Naeun Kim</strong></div>
  <div class="mini">글자가 케이크에 쌓여요 • 손님이 가져가요 🍰 → <kbd>Enter</kbd>로 초기화</div>
    <div>일반 키: <em>글자</em>가 케이크에 층층이 쌓여요</div>
    <div><kbd>Space</kbd>: 촛불 켜기/끄기 / <kbd>Enter</kbd>: 손님이 가져가요(초기화)</div>
  <div>숫자키: 스프링클</div>
    <div class="mini">과일 단축키를 찾으려면 물음표(?) 아이콘을 클릭해보세요</div>
    <div class="fruit-keys" style="display: none;">
      🍓: F키 / 🍎: A키 / 🫐: B키 / 🍒: C키 / 🍇: G키<br>
      🥭: M키 / 🥝: K키 / 🍑: P키 / 🍊: O키 / �: L키
    </div>
  </div>

  <div id="stage">
    <div class="plate"></div>
    <div id="cake" class="cake" aria-label="cake"></div>
  </div>
  <div id="footer">type to play • made for ID202 prototyping</div>

  <script>
  // ===== Audio — tiny synth & candle pad =====
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let audioContext = null;
  function getAudioContext(){ if(!audioContext) audioContext = new AudioCtx(); return audioContext; }

  function noteForKey(key){
    const scale = [261.63, 293.66, 329.63, 392.00, 440.00]; // C D E G A
    const index = (key.toUpperCase().charCodeAt(0) + 7) % scale.length;
    return scale[index] * (1 + ((key.charCodeAt(0)%5)-2)*0.01);
  }

  function blip(key){
    const ac = getAudioContext();
    const osc = ac.createOscillator();
    const gain = ac.createGain();
    osc.type = 'triangle';
    osc.frequency.value = noteForKey(key);
    gain.gain.value = 0.001;
    osc.connect(gain).connect(ac.destination);
    const now = ac.currentTime;
    gain.gain.linearRampToValueAtTime(0.12, now + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0008, now + 0.22);
    osc.start();
    osc.stop(now + 0.25);
  }

  let candleOsc = null, candleGain = null;
  function candleOn(){
    const ac = getAudioContext();
    candleOsc = ac.createOscillator();
    candleGain = ac.createGain();
    candleOsc.type = 'sine';
    candleOsc.frequency.value = 196;
    candleGain.gain.value = 0.0001;
    candleOsc.connect(candleGain).connect(ac.destination);
    const now = ac.currentTime;
    candleGain.gain.linearRampToValueAtTime(0.06, now + 0.6);
    candleOsc.start();
  }
  function candleOff(){
    if(!candleGain || !candleOsc) return;
    const ac = getAudioContext();
    const now = ac.currentTime;
    candleGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.2);
    candleOsc.stop(now + 0.25);
    candleGain = null; candleOsc = null;
  }

  // ===== Scene =====
  const stage = document.getElementById('stage');
  const cake  = document.getElementById('cake');
  const hud   = document.getElementById('hud');
  const hudToggle = document.getElementById('hud-toggle');
  let candlesLit = false;

  const randomBetween = (min,max)=> Math.random()*(max-min)+min;
  function cakeRect(){ return cake.getBoundingClientRect(); }

  // ===== Column stacking (non-overlapping pile) =====
  const stacking = {
    columnsCount: 24,
    columnWidth: 0,
    rowHeight: 34,
    baseTop: 0,
    baseLeft: 0,
    width: 0,
    stacks: [],
    recompute(){
      const cr = cakeRect();
      this.baseLeft = cr.left;
      this.baseTop = cr.top + 20; // surface reference
      this.width = cr.width;
      this.columnWidth = cr.width / this.columnsCount;
      this.stacks = new Array(this.columnsCount).fill(0);
    },
    getTarget(xCenter){
      // clamp and resolve column index
      const localX = Math.max(0, Math.min(xCenter - this.baseLeft, this.width - 1));
      const columnIndex = Math.floor(localX / this.columnWidth);
      const col = Math.max(0, Math.min(this.columnsCount - 1, columnIndex));
      const level = this.stacks[col] || 0;
      const left = this.baseLeft + col * this.columnWidth + this.columnWidth/2 + randomBetween(-8,8);
      const top = this.baseTop - (level * this.rowHeight);
      return { left, top, col };
    },
    occupy(col){ this.stacks[col] = (this.stacks[col] || 0) + 1; },
    reset(){ this.recompute(); }
  };

  // initialize stacking after layout
  window.addEventListener('load', ()=> stacking.recompute());
  window.addEventListener('resize', ()=> stacking.recompute());

  // Candles are created by special-character keys (see input handler).
  // Lighting is controlled by toggling the "lit" class on existing .candle elements.

  // ===== Spawn helpers =====
  function spawnBit({ text, className, emoji, color, fromRoof=false, giant=false, group=false, node=null }){
    // node: optionally pass a pre-created element (used for candles)
    let el = node || document.createElement('div');
    if(!node){
      el.className = 'bit ' + (className||'');
    }
    if(giant) el.classList.add('giant');

    // initial placement (start above the visible area)
    const stageRect = stage.getBoundingClientRect();
    const cakeRectLocal = cakeRect();
    const startX = fromRoof ? (cakeRectLocal.left + Math.random() * cakeRectLocal.width) : (stageRect.left + stageRect.width * (0.18 + Math.random()*0.64));
    el.style.position = 'absolute';
    el.style.left = startX + 'px';
    el.style.top = (-60 - Math.random()*30) + 'px';
    el.style.opacity = 0.98;

  if(emoji){ el.textContent = emoji; }
  else if(text){ el.textContent = text; }
  // avoid CSS keyframe fall interfering with our JS transition
  el.classList.remove('falling');
    if(color){ el.style.color = color; }

    stage.appendChild(el);

    // compute target column/position on cake
    const centerX = startX + (el.offsetWidth/2 || 8);
    const target = stacking.getTarget(centerX);

    // candles behave slightly differently: keep them on surface but do not occupy stack columns
    const isCandle = el.classList.contains('candle');
    // if candle, pick a pastel color from root variable list
    if(isCandle){
      const colors = getComputedStyle(document.documentElement)
        .getPropertyValue('--candle-colors').split(',').map(s=>s.trim()).filter(Boolean);
      const c = colors[Math.floor(Math.random()*Math.max(1,colors.length))] || '#ffd6e6';
      el.style.background = `linear-gradient(to bottom, ${c}, #ffffff)`;
      el.style.width = '6px';
      el.style.height = '110px';
      el.style.borderRadius = '3px';
    }
    const targetLeft = isCandle ? (target.left + randomBetween(-16,16)) : target.left;
    const targetTop = isCandle ? (stacking.baseTop - 4) : target.top;

    // animate to target using transition (duration proportional to distance)
    const dist = Math.abs((parseFloat(el.style.top) || -60) - targetTop);
    const dur = Math.max(0.35, Math.min(1.2, dist / 600));
    el.style.transition = `top ${dur}s linear, left ${dur}s linear, opacity ${dur}s linear`;

    // force reflow then set final position
    void el.offsetWidth;
    el.style.left = targetLeft + 'px';
    el.style.top = targetTop + 'px';

    el.addEventListener('transitionend', function onEnd(ev){
      if(ev.propertyName !== 'top') return;
      el.removeEventListener('transitionend', onEnd);
      el.style.transition = '';
      el.style.left = targetLeft + 'px';
      el.style.top = targetTop + 'px';
      el.classList.remove('falling');
      // occupy the column only for non-candles
      if(!isCandle) stacking.occupy(target.col);
    });

    // Optional group cascade (3 quick neighbors)
    if(group){
      for(let i=0;i<3;i++){
        setTimeout(()=>{
          spawnBit({ text, className, emoji, color, fromRoof:true });
        }, 120 + i*80);
      }
    }
  }

  function sprinkle(){
    const s = document.createElement('div');
    s.className = 'sprinkle falling';
    const stageRect = stage.getBoundingClientRect();
    s.style.left = randomBetween(stageRect.width*0.2, stageRect.width*0.8)+'px';
    const palette = ['#ff7a99','#ffd166','#8be9fd','#c2ff8f','#b197fc'];
    s.style.background = palette[Math.floor(randomBetween(0, palette.length))];
    s.style.setProperty('--dur', (randomBetween(1.6, 2.6)).toFixed(2)+'s');
    stage.appendChild(s);
    s.addEventListener('animationend', ()=> s.remove());
  }

  // ===== Guest arrives (reset) =====
  function guestEat(){
    const hand = document.createElement('div');
    hand.className = 'hand';
    hand.textContent = '🫱🏻\u200d🍰';
    stage.appendChild(hand);

    cake.classList.add('eaten');
    setTimeout(()=>{
      [...document.querySelectorAll('.bit,.sprinkle,.candle')].forEach(n=>n.remove());
      document.body.classList.remove('warm');
      candleOff();
      candlesLit = false;
      cake.classList.remove('eaten');
      hand.remove();
      stacking.reset();
    }, 950);
  }

  // ===== Input handling + playful surprises =====
  const toppingMap = { 'f':'🍓','a':'🍎','b':'🫐','c':'🍒','g':'🍇','m':'🥭','k':'🥝','p':'🍑','o':'🍊','l':'🍋' };
  const fruits = Object.values(toppingMap);
  let keyPressCount = 0;
  let gDownAt = 0; // long-press protection for G

  function randomFruit(){ return fruits[Math.floor(Math.random()*fruits.length)]; }

  function maybeSurprise(){
    // reserved for small surprises (disabled watermelon)
    return;
  }

  function handleKeyDown(e){
    if(e.key === ' '){ e.preventDefault(); }
    if(audioContext && audioContext.state === 'suspended') audioContext.resume();

    // HUD toggle with '?'
    if(e.key === '?' || (e.shiftKey && e.key === '/')){ hud.classList.toggle('hidden'); return; }

    // Space toggles candle lights
    if(e.key === ' '){ 
      document.querySelectorAll('.candle').forEach(c => c.classList.toggle('lit'));
      return;
    }

    // Enter to reset
    if(e.key === 'Enter'){ 
      [...document.querySelectorAll('.bit,.sprinkle,.candle')].forEach(n=>n.remove());
      return;
    }

    // Special characters create candles
    if(/^[\[\]\\;'\/.,`~!@#$%^&*()_+{}|:"<>?]$/.test(e.key)){
      const candle = document.createElement('div');
      candle.className = 'bit candle falling';
      spawnBit({ node: candle });
      blip(e.key);
      return;
    }

    // Numbers → sprinkles
    if(/[0-9]/.test(e.key)){ keyPressCount++; sprinkle(); blip(e.key); maybeSurprise(); return; }

    const keyLower = e.key.toLowerCase();

    // Fruits via explicit hotkeys OR random fruit (20% chance) even for letters
    if(toppingMap[keyLower] || Math.random() < 0.2){
      keyPressCount++;
      const emo = toppingMap[keyLower] || randomFruit();
      spawnBit({ emoji: emo, className:'topping', fromRoof: Math.random()<0.5 });
      blip(keyLower);
      maybeSurprise();
      return;
    }

    // Letters and symbols → falling letters
    if(e.key.length === 1){
      keyPressCount++;
      spawnBit({ text: e.key, className:'letter', fromRoof: Math.random()<0.6 });
      blip(e.key);
      maybeSurprise();
      return;
    }

    // Backspace removes last landed element
    if(e.key === 'Backspace'){
      const bits = [...document.querySelectorAll('.bit')];
      if(bits.length){ bits[bits.length-1].remove(); }
      return;
    }
  }

  function handleKeyUp(e){
    // No longer need to handle key up events
  }

  // HUD toggle button + auto-hide
  hudToggle.addEventListener('click', ()=> {
    hud.classList.toggle('hidden');
    document.querySelector('.fruit-keys').style.display = 
      hud.classList.contains('hidden') ? 'none' : 'block';
  });
  setTimeout(()=> hud.classList.add('hidden'), 5200);

  // Reset is handled via Enter key only (button removed)

  window.addEventListener('keydown', handleKeyDown);
  window.addEventListener('keyup', handleKeyUp);

  // Recompute stacking on resize
  window.addEventListener('resize', ()=> stacking.recompute());
  </script>
</body>
</html>
